<h1>Week</h1>
<h4><a href="https://s40723234.github.io/cad2019/content/week02-06.html">week02-05</a></h4>
<h4><a href="https://s40723234.github.io/cad2019/content/week06-09.html">week06-09</a></h4>
<h4><a href="https://s40723234.github.io/cad2019/content/week10-14.html">week10-14</a></h4>
<h4><a href="https://s40723234.github.io/cad2019/content/week15-18.html">week15-18</a></h4>
<h2>week02-06</h2>
<h4>week02</h4>
<h4>建立倉儲與開近端，以下有影片(開cc字幕)</h4>
<p>1.下載2019fall可攜程式至隨身碟</p>
<p>2. 設定user name和email及proxy</p>
<p>3. git clone 個人github倉儲</p>
<p>4. 利用submodule指令設定cmsimde</p>
<p>5. 設定flask_cors</p>
<p>6. 利用cmsimde python wsgi.py 開啟近端</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/b9afO4xBZfs" width="560"></iframe></p>
<h4>Week03</h4>
<h4>編譯Slovespace，以下有影片(開cc字幕)</h4>
<p>1. 將 Y:\portablegit\bin\sh.exe 改名為 sh_rename_for_solvespace.exe</p>
<p>2. 查驗 git 版本在 2.13 以上，即可使用 git clone --recurse-submodules 指令取得所有子模組資料</p>
<p>3. 將CMakeLists line 713 and 714 前面加上 #</p>
<p>4. 手動進行 libpng.dll.a 的編譯，並且改名為 libpng_static.a 後放到Y槽的 lib 目錄</p>
<p>5. 回到 solvespace 目錄， 建立 build 目錄後進入 build 目錄，執行以下兩行程式</p>
<p>cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release<br/>mingw32-make</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/sRQkXMsOqOE" width="560"></iframe></p>
<h4>Week04</h4>
<p>跟上week02與week03的進度</p>
<h4><span>Week05</span></h4>
<h4>Slovespace 操作，以下有影片(開cc字幕)</h4>
<p><span>1.  solvespace進行零組件繪製</span></p>
<p><span>2.  每人分別選擇要繪製之零組件</span></p>
<p><span>3.  利用solvespace進行繪製</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/Osbtpl47EsY" width="560"></iframe></span></p>
<h2>week06-09</h2>
<h4>week06</h4>
<h4><span>Solvespace 繪製，以下是影片(開cc字幕)</span></h4>
<p><span>1.  <span>利用 Solvespace 繪製雙輪車所需要的零組件</span></span></p>
<p><span><span>2.  首先繪製自走車之輪子</span></span></p>
<p><span><span>3.  繪製自走車本體</span></span></p>
<p><span><span>4.  開新檔組裝自走車本體與輪子</span></span></p>
<p><span><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/bqd2tKedOQ0" width="560"></iframe></span></span></p>
<h4><span>V-rep 模型控制，以下有影片(開cc字幕)</span></h4>
<p><span>1.<span><span> 下載<span>V-rep 3.6.1 rev4 與 web_vrep2.zip(local)</span></span></span></span></p>
<p><span><span><span><span>2.  開啟V-rep 3.6.1 rev4裡的vrep.exe後開啟 web_vrep2裡的two_wheeler.ttt</span></span></span></span></p>
<p><span><span>3.  利用小白框開啟web_vrep2裡的app.py以開啟localhost:5000</span></span></p>
<p><span><span>4.  利用localhost:5000操控小車轉向與速度</span></span></p>
<p><span><span>5.  web_vrep2裡沒有remoteApi.dll檔的話，要到V-rep 3.6.1 rev4找到programming裡</span></span></p>
<p><span><span>remoteApiBindings裡lib裡Windows裡64bit裡複製到web_vrep2，才可使用app.py開</span></span></p>
<p><span><span>啟localhost:5000操控小車</span></span></p>
<p><span><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/5ZkijUQDTAc" width="560"></iframe></span></span></p>
<h4><span>新增啟動與停止按鈕，以下是影片(開cc字幕)</span></h4>
<p><span>1.  首先開啟 wed_vrep2 資料夾裡tempate資料夾的controls進編輯器</span></p>
<p><span>2.  利用原有按鈕的程式進行複製修改，新增啟動及停止的按鈕</span></p>
<p><span>3. 接著拉wed_vrep2 資料夾裡的 vrep_linefollower.py檔進編輯器</span></p>
<p><span>4. 在 def to direction 下加上 if direction == 'start': 後打上vrep.simxStartSimulation(self.clientID, vrep.simx_opmode_oneshot)  定義開始按鈕</span></p>
<p><span>5. 接著打上  elif direction == 'stop':<br/>vrep.simxStopSimulation(self.clientID, vrep.simx_opmode_oneshot) 定義停止按鈕</span></p>
<p><span>6.  後續打上else :  並排列好順序</span></p>
<p><span>7. 利用 app.py 開啟 localhost:5000 </span></p>
<p><span>8. 打開vrep 導入雙輪車，利用   localhost:5000  進行開始與停止操控</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/9zgR51-knq4" width="560"></iframe></span></p>
<h4>week07</h4>
<h4>Slovespace編譯，以下是影片(開cc字幕)</h4>
<p><span>1.  </span>到tmp &gt; solvespace &gt; build &gt;src &gt;CMakeFiles &gt; solvespace.dir刪掉           slovespace.cpp.obj檔</p>
<p>2. 到<span> solvespace &gt;src找到  slovespace.cpp 拉進編輯器</span></p>
<p><span>3. 利用ctrl + f 進行搜尋 ，找GPL</span></p>
<p><span>4.  找到  this  is  <span>solvespace 在後面加上 is compiled by 自己學號</span></span></p>
<p><span><span>5. 利用小黑框，路徑移置 tmp &gt; solvespace &gt; build 打上 mingw32-makemingw32-make 指令</span></span></p>
<p><span><span>6. 完成後到 solvespace &gt; build &gt;bin 開啟 slovespace.exe ，進help 點 about 確認驗證完成</span></span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/g70d6pMRUsA" width="560"></iframe></span></p>
<h4><span>Sol</span><span>vespace 繪圖認證，以下是影片(開cc字幕)</span></h4>
<p><span>1.  繪製零件3</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/DBnXRljGVno" width="560"></iframe></span></p>
<h4>week08</h4>
<h4><span>CMSimfly網際內容管理啟用，以下是影片(開cc字幕)</span></h4>
<p><span>1. </span><span>leo </span></p>
<p><span>2. 到cad2019&gt;config資料夾找到pelican.leo拉進開啟的leo裡 </span></p>
<p><span>3. 開啟個人網頁home下裡的blog，複製個人blog網址</span></p>
<p><span>4.  到leo裡的path裡的pelican裡的遠端下，把個人部落格網址貼上 ，然後把名稱改成個人學號</span></p>
<p><span>5. 點旁邊的 local blog按右鍵點goto script</span></p>
<p><span>6. 複製pelican markdown -o blog -s local_publishconf.pypelican markdown -o blog -s local_publishconf.py指令，利用小黑框將位置改至個人倉儲，貼上指令</span></p>
<p><span>7.  完成後到cad2019 &gt; blog 檢查有東西後，開啟 localhost8444確定blog啟用成功後git push上去即完成</span></p>
<p><span><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/bpjL9nsMWO0" width="560"></iframe></span></p>
<h4>導入webots</h4>
<h4><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/p9Pk0C7Oi9Q" width="560"></iframe></h4>
<h4>week09</h4>
<p>期中報告影片</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/twk2Sa3rit4" width="560"></iframe></p>
<h2>week10-14</h2>
<h4>week10</h4>
<p><span>分組並建立組別倉儲</span></p>
<p>1.由組長創建<span>分組網站</span><a href="https://s40723221.github.io/cad2019bg2/content/index.html" rel="nofollow">https://s40723221.github.io/cad2019bg2/content/index.html</a>和<span>分組倉儲</span><a href="https://github.com/s40723221/cad2019bg2">https://github.com/s40723221/cad2019bg2</a></p>
<p><img alt="" height="244" src="/images/cad2019 群組圖.jpg" width="663"/></p>
<p><img alt="" height="238" src="/images/cad2019 群組網站.jpg" width="604"/></p>
<p>2.加入創建之分組網站</p>
<p>3.加入後用git  clone submodules 組別倉儲網址</p>
<p><img alt="" height="259" src="/images/小黑框.jpg" width="460"/> </p>
<p>4.以git pull request的方式進行推送</p>
<p>5 .nx12 / nx3的操作手冊和教程</p>
<p><img alt="" height="195" src="/images/nx.jpg" width="186"/></p>
<ul>
<li><span>nx12及nx3下載點和資料參考點(虛擬主機板本): </span><span><a class="yt-simple-endpoint style-scope yt-formatted-string" href="https://www.youtube.com/redirect?redir_token=zliIh6Mnwm5VSEpZ9Ty2Si95XGp8MTU3NDE1NjIzMkAxNTc0MDY5ODMy&amp;q=http%3A%2F%2Fmde.tw%2Fcad2019%2Fcontent%2FNX.html&amp;event=video_description&amp;v=hTJygEIdV3g" rel="nofollow" spellcheck="false" target="_blank">http://mde.tw/cad2019/content/NX.html</a></span></li>
<li><span>VirtualBox下載點: <span><a class="yt-simple-endpoint style-scope yt-formatted-string" href="https://www.youtube.com/redirect?redir_token=zliIh6Mnwm5VSEpZ9Ty2Si95XGp8MTU3NDE1NjIzMkAxNTc0MDY5ODMy&amp;q=https%3A%2F%2Fbriian.com%2F5690%2F&amp;event=video_description&amp;v=hTJygEIdV3g" rel="nofollow" spellcheck="false" target="_blank">https://briian.com/5690/</a></span></span></li>
<li>
<p><span>nx12及nx3下載點和資料參考點: <a class="yt-simple-endpoint style-scope yt-formatted-string" href="https://www.youtube.com/redirect?redir_token=Bfh5TKJYw50ymafsWRpHmHpfLDd8MTU3NDE1NjQ1MkAxNTc0MDcwMDUy&amp;q=http%3A%2F%2Fmde.tw%2Fcad2019%2Fcontent%2FNX.html&amp;event=video_description&amp;v=onJNFA_U7gk" rel="nofollow" spellcheck="false" target="_blank">http://mde.tw/cad2019/content/NX.html</a></span></p>
</li>
<li>
<p>solidwork下載點和資料參考點:<span> <a class="yt-simple-endpoint style-scope yt-formatted-string" href="https://www.youtube.com/redirect?redir_token=Bfh5TKJYw50ymafsWRpHmHpfLDd8MTU3NDE1NjQ1MkAxNTc0MDcwMDUy&amp;q=http%3A%2F%2Fmde.tw%2Fcad2019%2Fcontent%2FSolidworks.html&amp;event=video_description&amp;v=onJNFA_U7gk" rel="nofollow" spellcheck="false" target="_blank">http://mde.tw/cad2019/content/Solidwo...</a></span></p>
</li>
<li>
<p>VirtualBox下載點: <span><a class="yt-simple-endpoint style-scope yt-formatted-string" href="https://www.youtube.com/redirect?redir_token=Bfh5TKJYw50ymafsWRpHmHpfLDd8MTU3NDE1NjQ1MkAxNTc0MDcwMDUy&amp;q=https%3A%2F%2Fbriian.com%2F5690%2F&amp;event=video_description&amp;v=onJNFA_U7gk" rel="nofollow" spellcheck="false" target="_blank">https://briian.com/5690/</a></span></p>
</li>
</ul>
<h4>week11</h4>
<p>校慶週</p>
<h4>week12</h4>
<p><span>1.翻譯電子書內容(第6章)</span></p>
<p><span><span>2.參考NX設計電子書 : <a href="http://mde.tw/cad2019/downloads/NX-12-for-Engineering-Design.pdf"> http://mde.tw/cad2019/downloads/NX-12-for-Engineering- Design.pdf </a></span></span></p>
<h4>第<span>6</span>章<span>-</span>部件建模</h4>
<p>    每天，我們都會看到許多將組件組裝成一個模型的示例，例如自行車，汽車和計算機。 所有這些產品都是通過設計和製造單個零件，然後將它們裝配在一起。 創造它們的設計師有仔細計劃每個零件，使它們完美地配合在一起以執行所需的操作功能。</p>
<p>    在本章中，您將學習在裝配體建模中使用的兩種方法。 我們會以葉輪組件為例練習裝配建模。 這個的某些部分前面的章節已經對程序集進行了建模。</p>
<p>NX12裝配體是一個零件文件，其中包含各個零件。 它們被添加到零件文件中這樣一來，零件實際上就位於裝配體中並鏈接到原始零件。 這個無需為計算機中的各個部件創建單獨的內存空間。</p>
<p>所有零件都是可選的，可在設計過程中用於信息和配合。確保設計師想要的完美契合。 下圖顯示了組件如何添加以進行裝配。</p>
<p> <img alt="" height="137" src="/images/chap6.jpg" width="305"/></p>
<p>6.1術語</p>
<p><strong>部件</strong></p>
<p>部件體是指向零件和<span>/</span>或子裝配體的指針的集合。 部件是零件文件，其中包含組件對象</p>
<p><strong>組件對象</strong></p>
<p>零部件對像是指向包含零部件的零件文件的非幾何指針幾何。 組件對象存儲諸如圖層，顏色，參考集，位置之類的信息相對於文件系統中零件的裝配體和路徑的零件數據。</p>
<p><strong>組成部分</strong></p>
<p>零件是指的零件文件裝配件中的零部件對象。 實際幾何存儲在組件中部分並被引用，而不是被部件</p>
<p><img alt="" height="224" src="/images/6.1-3.jpg" width="496"/></p>
<p><strong>組件發生</strong></p>
<p>零部件的出現是零部件文件中指向幾何的指針。</p>
<p> 使用組件在不創建其他幾何圖形的情況下創建對零部件的一個或多個引用的實例。</p>
<p><strong>參考集</strong></p>
<p>參考集是零部件或子裝配體中的對象的命名集合，您可以用於簡化高層裝配中零部件的表示。</p>
<p>6.2組裝方法</p>
<p>創建任何裝配體模型有兩種基本方法。</p>
<ul>
<li>Top-Down Approach( 自上而下的方法 <span>)</span></li>
<li>Bottom-Up Approach( 自下而上的方法 <span>)</span><span></span></li>
</ul>
<p><strong><img alt="" height="602" src="/images/6.2.jpg" width="432"/></strong></p>
<p><strong>6.2.1</strong><strong>自上而下的方法</strong></p>
<p>通過這種方法，將創建裝配零件文件。首先，在該文件中創建組件， 然後各個零件均已建模。</p>
<p>這類建模在新設計中很有用。</p>
<p><strong>6.2.2</strong><strong>自下而上的方法</strong></p>
<p>首先在傳統方式，然後添加到裝配中零件文件。 這項技術特別有用，以前的零件文件已經存在時設計，並且可以重複使用。</p>
<p><strong>6.2.3</strong><strong>混合搭配</strong></p>
<p>您可以將這兩種方法結合起來必要的，以增加裝配的靈活性設計需求。</p>
<p>6.3部件與約束導航儀</p>
<p>部件導航器和約束導航器位於部件導航器的頂部屏幕左側的資源欄。</p>
<p>這些導航器向您展示了構成裝配體，包括零件層次結構，零件名稱，有關零件的信息，例如是否部分是只讀的，對像數和約束狀態。</p>
<p><img alt="" height="327" src="/images/6.3.jpg" width="248"/></p>
<p>6.4匹配約束</p>
<p>將零部件對象添加到裝配零件文件後，將對每個零部件對象進行配對與現有對象。 通過在部件的零部件上分配配合條件，您可以在這些組件之間建立位置關係或約束。 這些關係是</p>
<p>稱為交配約束。 配合條件由一個或多個配合約束組成。</p>
<p>有不同的配合約束，如下所述：</p>
<ul>
<li>觸摸<span>/</span>對齊：選定要對齊的平面對象將是共面的，但平面的法線將指向同一方向。</li>
</ul>
<p>                             圓柱物體的中心線將與每個其他。</p>
<ul>
<li>同心<span> : </span>約束兩個分量的圓形或橢圓形邊緣，因此中心為重合併且邊緣的平面共<span>              </span>面。</li>
<li>距離：在兩個對象之間建立一個<span>+/-</span>距離（偏移）值</li>
<li>平行<span> </span>：所選對象將彼此平行。</li>
<li>垂直<span> </span>：所選對象將彼此垂直。</li>
<li>鍵合<span> </span>：創建焊接並將零件焊接在一起以作為單個對象移動。</li>
<li>居中<span> </span>：對象將在其他對象之間居中，即沿槽定位圓柱體</li>
</ul>
<p>                          並將圓柱體在插槽中居中。</p>
<ul>
<li>角度<span> </span>：這將在組件上選擇的兩個對象實體之間固定一個恆定的角度</li>
</ul>
<p>                          組裝。</p>
<p><img alt="" height="402" src="/images/6.4.jpg" width="156"/></p>
<p>6.5範例</p>
<p>組裝葉輪組件。</p>
<p>其中建模了所有組件， 現在我們必須將它們插入組裝環境並應用將它們相對放置的約束。 組裝完成後，我們可以創建分解圖並準備繪圖。</p>
<p>在開始裝配建模之前，請在<span>Hexabolt</span>的葉輪下部殼體和葉輪上部殼體的每一側上分別製造三個通孔（每個殼體總共<span>6</span>個孔）。 孔的直徑應為<span>0.25。</span></p>
<p><span><img alt="" height="207" src="/images/6.5.jpg" width="319"/></span></p>
<p><strong>6.5.1</strong><strong>開始組裝</strong></p>
<p>➢創建一個新文件</p>
<p>➢在模型選項卡下選擇裝配</p>
<p>➢將單位設置為英寸</p>
<p>➢命名為<span>Impeller_assembly.prt</span></p>
<p><span><img alt="" height="363" src="/images/6.5-4.jpg" width="462"/></span></p>
<p>或者，如果您在“建模應用程序”中並想要開始組裝，</p>
<p>➢在應用程序選項卡中打開程序集選項，然後會出現一個新的程序集選項卡</p>
<p>或者</p>
<p>➢單擊文件→程序集，如下所示</p>
<p>➢主頁菜單欄現在將顯示用於組裝的工具</p>
<p>在組件選項中：</p>
<ul>
<li>“添加”選項添加已創建其零件文件的新零部件對象。</li>
<li>“新建”可讓您在裝配文件中創建新的零件幾何體</li>
</ul>
<p>正在使用自頂向下方法進行組裝。</p>
<p>裝配約束允許您創建裝配約束，而移動零部件允許您可以將零部件重新放置在裝配中所需的任何位置。</p>
<p><strong>6.5.2</strong><strong>添加組件和約束</strong></p>
<p>➢選擇添加</p>
<p>右側顯示的對話框將彈出。您可以從現有文件中選擇零件文件（應該已經顯示在“已加載的零件”選項卡中），也可以加載零件文件使用對話框中的打開文件選項。這將加載</p>
<p>選定的零件文件進入“加載的零件”對話框。</p>
<p>➢單擊打開圖標並選擇文件</p>
<p>Impeller_upper-casing.prt</p>
<p>➢在零件名稱對話框中單擊確定。</p>
<p>然後我們需要設置一個位置來放置坐標系</p>
<p>第一部分的。在位置組框中，保持“裝配位置”選項的默認“捕捉”。</p>
<p>➢單擊選擇對象</p>
<p>現在可以在透明模式下看到零件</p>
<p>➢單擊指向對話框圖標並創建[0，<span>0</span>，<span>0]</span>的坐標</p>
<p>➢單擊確定退出點對話框</p>
<p>注意：可以隨意使用“循環方向”選項來設置不同的方向。</p>
<p>➢在“放置”組框中，我們可以定義放置此組件的位置和方式。在這種情況下，</p>
<p>我們將保留默認選項。</p>
<p>➢單擊確定退出添加組件對話框</p>
<p>然後，您將看到一個彈出對話框。</p>
<p>➢單擊“是”為該零件創建一個“修復”約束。</p>
<p>讓我們繼續添加第二個組件，即下部外殼。</p>
<p>➢單擊裝配部分中的添加</p>
<p>➢從<span>Loded Parts</span>中選擇文件<span>Impeller_lower-casing.prt</span>或打開</p>
<p>➢在位置組框中，將選項更改為絕對–工作零件以放置新的部分位於當前工作部分的絕對原點</p>
<p>➢在“放置”組框中，首先切換“移動”單選按鈕並移動下殼體遠離上殼體，以便有足夠的空間選擇配合面。</p>
<p>➢然後，切換約束單選按鈕。現在，讓我們配對上殼體和下殼體。</p>
<p>您可以在“約束類型”框中的下拉菜單中訪問所有約束。</p>
<p>在這裡您可以看到不同的交配類型，上面已經解釋過了部分。</p>
<p>➢確保觸摸對齊圖標為在“類型”對話框中選擇</p>
<p>➢首先，選擇箭頭所在的面。</p>
<p>➢如右圖所示，在屏幕上單擊上殼體的表面。</p>
<p>注意：如果由於零件的位置而難以選擇面，則可以移動</p>
<p>通過在“放置”組框中切換“移動”並操縱其處理程序來調整它們。</p>
<p>讓我們添加另一個“觸摸對齊”約束。</p>
<p>➢確保您仍在使用觸摸對齊</p>
<p>➢單擊上殼體的平面，然後單擊相應的平面。</p>
<p>下殼體相對於上殼體受到約束。 現在讓我們添加葉輪。</p>
<p>➢選擇裝配→零部件→添加以將零部件添加到當前裝配中</p>
<p>➢打開文件<span>Impeller_impeller.prt</span></p>
<p>➢在對話框中單擊確定</p>
<p>➢選擇絕對–裝配<span>Locat</span>的工作零件</p>
<p>➢切換約束按鈕</p>
<p>➢單擊“約束類型”框中的“距離”圖標</p>
<p>➢選擇兩個面，首先在葉輪上，然後在殼體上，</p>
<p>➢在“位置”組的“距離”框中，輸入值<span>3</span></p>
<p>➢按<span>Enter</span>預覽當前裝配</p>
<p>預覽可能會顯示葉輪的方向與我們想要的方向相反。</p>
<p>➢要更改零件的方向或距離方向，請在“放置”窗口中，單擊“要約束的幾何”框中的“循環最後約束”按鈕。</p>
<p>從預覽中檢查裝配狀態，您可能需要單擊多個按鈕次以獲得理想的結果。 現在，葉輪將朝向正確的方向。</p>
<p>現在，我們將使用“中心”約束添加軸。</p>
<p>➢單擊裝配→零部件→添加</p>
<p>➢打開文件<span>Impeller_shaft.prt</span></p>
<p>➢在對話框中單擊確定</p>
<p>➢在約束中選擇“觸摸對齊”圖標文字框在菜單中選擇推斷中心<span>/</span>軸選項幾何約束框</p>
<p>➢選擇兩個表面，首先在軸上，然後在葉輪上</p>
<p>➢保持觸摸對齊約束</p>
<p>➢在“幾何要約束”框中選擇“首選觸摸”選項</p>
<p>➢首先，選擇軸上的面，然後選擇葉輪中孔的底面</p>
<p>➢單擊裝配→零部件→添加</p>
<p>➢打開文件<span>Impeller_hexa-bolt.prt</span></p>
<p>➢選擇“觸摸對齊”約束。 使用幾何中的推斷中心<span>/</span>軸選項約束框</p>
<p>➢首先，選擇螺栓上的外部圓柱螺紋，然後選擇螺栓的內表面。</p>
<p>➢再次在“觸摸對齊”約束中將“將幾何約束為約束”選項更改為“首選”觸摸</p>
<p>➢如圖所示，選擇螺栓上的平面和上殼體肋板上的平面</p>
<p>➢點擊確定</p>
<p>➢重複相同的步驟，在組件的所有孔中添加螺栓和螺母。</p>
<p>這樣就完成了葉輪的組裝。</p>
<p>注意：有一種簡單的方法來組裝螺栓和螺母套件。 而不是添加三個部分</p>
<p>您可以分別將這些組件分別組裝到另一個文件中。 這將是一個子裝配。 您可以插入此子裝配並將其與主裝配配對。</p>
<p><strong>6.5.3</strong><strong>分解圖</strong></p>
<p>在本節中，我們將創建裝配體的分解圖，以顯示組成裝配體的零部件的分離的零件圖片。在當今的工業實踐中，這些此類視圖在裝配車間非常有用，有助於您更好地了解要修復的項目</p>
<p>哪裡。用戶應了解，爆炸裝配並不意味著零件的重新定位。</p>
<p>組件，但只能以拆卸的形式查看模型。您可以取消分解視圖您隨時可以重新獲得原始裝配視圖。讓我們爆炸葉輪組件。</p>
<p>➢選擇菜單→裝配體→分解圖→新爆炸</p>
<p>這將彈出一個對話框，詢問您的名稱。要創建的爆炸視圖。你可以留下名字，作為默認名稱，然後選擇確定，現在，<span>NX</span>環境處於爆炸視圖中環境，儘管您沒有發現任何區別。當我們開始爆炸裝配時，我們應該確定一個組件以使該組件作為參考。該組件應不能從其原始位置移動。對於葉輪組件，葉輪將是正確的選擇，因為它對於整個裝配至關重要。現在讓我們開始分解這些組件。</p>
<p>➢右鍵單擊上殼體，然後選擇“編輯爆炸”</p>
<p>“編輯爆炸”窗口將與組件上的坐標手柄一起彈出。</p>
<p>➢點擊<span>Z</span>軸； 按住鼠標並向上拖動，直到顯示距離，顯示<span>-20</span>（如果設計方向相反，則用<span>+20</span>代替）</p>
<p>➢點擊確定</p>
<p>➢右鍵單擊下部外殼，然後選擇“編輯爆炸”</p>
<p>再次，這將彈出一個對話框，用於編輯爆炸和零件上的坐標系。</p>
<p>➢點擊<span>Z</span>軸； 按住鼠標並拖動向下直到距離讀數顯示<span>20</span>，如右圖所示</p>
<p>側。</p>
<p>➢右鍵單擊軸，然後選擇“編輯”爆炸</p>
<p>➢這次點擊<span>X</span>軸； 按住按鈕並拖動到右側，直到閱讀</p>
<p>距離顯示為<span>-25</span></p>
<p>➢選擇確定</p>
<p>➢單擊組件中的所有六個六角形螺栓</p>
<p>➢右鍵單擊其中之一，然後選擇“編輯爆炸”</p>
<p>➢這次單擊<span>Z</span>軸； 按住按鈕並向上拖動，直到讀取距離顯示<span>25</span>，如下圖所示。 這將移動所有六個螺栓在一起到相同的距離。</p>
<p>➢選擇確定</p>
<p>➢同樣，將六個墊圈和六個六角螺母向下移至<span>-30</span>和<span>-35</span>，分別是裝配體的分解圖。 您可以旋轉並查看其外觀。</p>
<p>如果您想回到原始的未爆炸視圖，</p>
<p>➢單擊功能區中的爆炸視圖→從下拉菜單中選擇（無爆炸）</p>
<p>如下所示，您可以取消分解裝配中的任何零部件，</p>
<p>➢右鍵單擊該組件，然後選擇“展開”。</p>
<p>如果要解開所有組件</p>
<p>➢選擇裝配體→爆炸視圖→展開零件</p>
<p><img alt="" height="300" src="/images/6.5-f.jpg" width="442"/></p>
<h4>6.6練習</h4>
<p><strong>6.6.1</strong><strong>刀桿壓機</strong></p>
<p>在本教程的前面各節中，我們對各個部分進行了建模，其中一些是手動壓榨機的組件如下所示。使用以下組件組裝手壓機除了提供給您的模型（以前從未建模）之外，您還進行了建模。</p>
<p>下文提供了手動壓榨機總成零件的完整列表。所有這些部分都是提供在一個文件夾中，該文件夾可以與本教程一起在同一<span>Internet</span>地址中訪問</p>
<p>（<span>https://web.mst.edu/~mleu/</span>）。</p>
<ul>
<li>艾倫·博爾特</li>
<li>艾倫堅果</li>
<li>基礎</li>
<li>圓底</li>
<li>尾夾</li>
<li>提手</li>
<li>六角螺栓</li>
<li><span>L</span>型桿</li>
<li>銷</li>
<li>小齒輪</li>
<li>小齒輪手柄</li>
<li>盤子</li>
<li>機架</li>
<li>袖長</li>
</ul>
<p><strong><img alt="" height="424" src="/images/6.6.1.jpg" width="377"/></strong></p>
<p><strong>6.6.2</strong><strong>蝶閥</strong></p>
<p>蝶閥是控制流量最常用的設備之一。蝶閥由位於管道中的旋轉盤組成。光盤安裝在所連接的軸上</p>
<p>到閥門外部的執行器上。旋轉致動器可以使光盤平行或平行旋轉垂直於流動。閥門關閉後，將閥瓣旋轉，使其完全阻塞離開通道。當閥門完全打開時，閥瓣旋轉四分之一圈，以便流體幾乎不受限制地通過。閥門也可以逐漸打開以調節流。</p>
<p>在本練習中，您將建模和組裝由<span>9</span>個不同零件組成的蝶形閥，用於共有<span>12</span>個組件。 以及不同零件的名稱，圖紙和尺寸提供各種組件如何裝配在一起的信息。 沒有圖紙的零件給定的設計或選擇，例如圓頭機螺釘。 所有尺寸以英寸為單位。</p>
<p><img alt="" height="547" src="/images/6.6.2-1.jpg" width="484"/></p>
<p></p>
<p><img alt="" height="570" src="/images/6.6.2-2.jpg" width="464"/></p>
<p></p>
<p><img alt="" height="648" src="/images/6.6.2-3.jpg" width="339"/></p>
<p>6.6.3 Jackscrew</p>
<p>千斤頂螺釘是一種通過轉動導螺桿來操作的千斤頂。 在這個練習中，要求您對零件進行建模，組裝和準備。 所有尺寸應以毫米為單位。 為每個創建單獨的草稿零件。 起草最終裝配並製作表格，列出每個人組件。 大會草案應有分解圖。</p>
<p><img alt="" height="653" src="/images/6.6.3.jpg" width="511"/></p>
<p><img alt="" height="653" src="/images/6.6.3.jpg" width="511"/></p>
<p>以下是影片(開cc字幕)</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/UQ2CseJ0m90" width="560"></iframe></p>
<p><span>webot tutorial - 1</span></p>
<p>1.建立資料夾</p>
<p>2.建一個新世界</p>
<p>3.先加號加入一個木箱並修改其尺寸</p>
<p>4.添加完成了之後我們要複製三個木箱</p>
<p>5.添加e-puck robot並且啟動試試看是否可以運動</p>
<p>6.增加控制器操縱e-puck robot添加指令後機器人應該會直走並旋轉後停下</p>
<p>7.修改這個控制器的功能貼上另一個指令如果成功機器人因該會緩慢行走</p>
<p>8.修改機器人馬達使其達原地旋轉</p>
<p><span>v-rep tutorial - bubbleRob</span></p>
<p>1.建一圓球作機器人本體</p>
<p>2.將感測器設好並且裝上機器人然後去定義其範圍</p>
<p>3.將左輪裝上並且把座標調整到適當位置，調整完之後將參數都設置好</p>
<p>4.調整好之後我們需要裝上右輪</p>
<p>5.增加第三個支點</p>
<p>6.增加一個小球當作機器人的支點</p>
<p>7.增加動力源並且設置好動力源的座標</p>
<p>8.左右輪也必須加上馬達當作動力源</p>
<p>9.設定都好了之後記得要將剛剛設定的東西都拉到bubbleRob底下才會跟著本體作動</p>
<p>10.設定障礙物將本體圍繞起來</p>
<p>11.設定運動時的動態圖表</p>
<p>12設定攝像頭以便機器人移動時看到與他平行的影像</p>
<p>13.將BubbleRob的程式碼功能打開並且將程式碼複製貼入到裡面</p>
<p>14.正常狀態下機器人因該會在感測器照射到物體的情況下往後退並迴避</p>
<h2>week15-18</h2>
<h4>week15</h4>
<p>review 期中考之後的進度，以下是影片(開cc字幕)</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/XNjyjBDWteU" width="560"></iframe></p>
<h4>week16</h4>
<p>測驗，以下是影片(開cc字幕)</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/SHsjAOoRmbw" width="560"></iframe></p>
<h4>week17</h4>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/dlanmIau7f4" width="560"></iframe>以上是影片(開cc字幕)</p>
<p>Now we are ready to define our model.</p>
<p>We start by building the model herarchy: we attach the last dynamic robot link (<em>robot_link_dyn6</em>) to its corresponding joint (<em>robot_joint6</em>) by selecting <em>robot_link_dyn6</em>, then control-selecting <em>robot_joint6</em>, then [Menu bar --&gt; Edit --&gt; Make last selected object parent]. We could also have done this step by simply dragging object <em>robot_link_dyn6</em> onto <em>robot_link6</em> in the <span><a href="http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm#SceneHierarchy">scene hierarchy</a></span>. We go on by now attaching <em>robot_joint6</em> to <em>robot_link_dyn5</em>, and so on, until arrived at the base of the robot. We now have following scene hierarchy:</p>
<p>現在我們準備定義模型了。</p>
<p>我們從建立模型層次結構開始：通過選擇<span>robot_link_dyn6</span>，然後控制選擇<span>robot_joint6</span>，然後選擇<span>[</span>菜單欄<span>-&gt;</span>編輯<span>-&gt;</span>創建最後一個選定的對象，將最後一個動態機器人鏈接（<span>robot_link_dyn6</span>）附加到其相應的關節（<span>robot_joint6</span>）。 父母<span>]</span>。 我們還可以通過簡單地將對象<span>robot_link_dyn6</span>拖到場景層次結構中的<span>robot_link6</span>上來完成此步驟。 現在，我們將<span>robot_joint6</span>附加到<span>robot_link_dyn5</span>上，依此類推，直到到達機器人的底部。 現在，我們具有以下場景層次結構：</p>
<p>*photo<img alt="" height="791" src="/images/photo 01.png" width="493"/></p>
<p>It is nice and more logical to have a simple name for the model base, since the model base will also represent the model itself. So we rename <em>robot</em> to <em>robot_visibleBase</em>, and <em>robot_dyn</em> to <em>robot</em>. Now we select the base of the hierarchy tree (i.e. object <em>robot</em>) and in the <span><a href="http://www.coppeliarobotics.com/helpFiles/en/commonPropertiesDialog.htm">object common properties</a></span> we enable <strong>Object is model base</strong>. We also enable <strong>Object/model can transfer or accept DNA</strong>. A model bounding box appeared, encompassing the whole robot. The bounding box however appears to be too large: this is because the bounding box also encompasses the invisible items, such as the joints. We now exclude the joints from the model bounding box by enabling the <strong>Don't show as inside model selection</strong> item for all joints. We could do the same procedure for all invisible items in our model. This is also a useful option in order to also exclude large sensors or other items from the model bounding box. We now have following situation:</p>
<p>為模型庫起一個簡單的名字是很好而且更合乎邏輯的，因為模型庫也將代表模型本身。 因此，我們將<span>robot</span>重命名為<span>robot_visibleBase</span>，並將<span>robot_dyn</span>重命名為<span>robot</span>。 現在我們選擇層次結構樹的基礎（即對像機械手），並在對象公共屬性中啟用<span>``</span>對像是模型基礎<span>''</span>。 我們還使對象<span>/</span>模型可以轉移或接受<span>DNA</span>。 出現了一個模型包圍盒，包圍了整個機器人。 但是，邊界框似乎太大：這是因為邊界框還包含不可見的項，例如關節。 現在，通過對所有關節啟用“不顯示為內部模型”選擇項，將關節從模型邊界框中排除。 我們可以對模型中的所有不可見項執行相同的過程。 這也是一個有用的選項，可以將大型傳感器或其他項目也排除在模型邊界框之外。 我們現在有以下情況：</p>
<p>*photo 02</p>
<p><img alt="" height="317" src="/images/photo 02.png" width="647"/></p>
<p>We now protect our model from accidental modification. We select all visible objects in the robot, then enable <strong>Select base of model instead</strong>: if we now click a visible link in the scene, the base of the robot will be selected instead. This allows us to manipulate the model as if it was a single object. We can still select visible objects in the robot via control-shift-clicking in the scene, or by selecting the object in the scene hierarchy. We now put the robot into a correct default position/orientation. First, we save current scene as a reference (e.g. if at a later stage we need to import CAD data that have the same orientation at the curent robot). Then we select the model and <span><a href="http://www.coppeliarobotics.com/helpFiles/en/coordinateDialog.htm">modify its position/orientation</a></span> appropriately. It is considered good practice to position the model (i.e. its base object) at X=0 and Y=0.</p>
<p>現在，我們保護模型免受意外修改。 我們選擇機器人中的所有可見對象，然後啟用“選擇模型的基礎”：如果現在單擊場景中的可見鏈接，則會改為選擇機器人的基礎。 這使我們可以像對待單個對像一樣操作模型。 我們仍然可以通過按住<span>Shift</span>鍵並單擊場景或在場景層次中選擇對象來選擇機器人中的可見對象。 現在，我們將機器人置於正確的默認位置<span>/</span>方向。 首先，我們將當前場景保存為參考（例如，如果稍後需要在當前機器人上導入方向相同的<span>CAD</span>數據）。 然後，我們選擇模型並適當修改其位置<span>/</span>方向。 將模型（即其基礎對象）定位在<span>X = 0</span>和<span>Y = 0</span>處被認為是一種好習慣。</p>
<p>*photo 03</p>
<p><img alt="" height="598" src="/images/photo 03.png" width="758"/></p>
<p>We now run the simulation: the robot will collapse, since the joints are not controlled by default. When we added the joints in the previous stage, we created joints in force/torque mode, but their motor or controller was disabled (by default). We can now adjust our joints to our requirements. In our case, we want a simple PID controller for each one of them. In the joint dynamic properties, we click Motor enabled and adjust the maximum torque. We then click Control loop enabled and select Position control (PID). We now run the simulation again: the robot should hold its position. Try to switch the current physics engine to see if the behaviour is consistent across all supported physics engines. You can do this via the appropriate toolbar button, or in the general dynamics properties.</p>
<p> </p>
<p>During simulation, we now verify the scene dynamic content via the Dynamic content visualization &amp; verification toolbar button. Now, only items that are taken into account by the physics engine will be display, and the display is color-coded. It is very important to always do this, and specially when your dynamic model doesn't behave as expected, in order to quickly debug the model. Similarly, always look at the scene hierarchy during simulation: dynamically enabled objects should display a ball-bounding icon on the right-hand side of their name.</p>
<p> </p>
<p>現在我們運行模擬：由於默認情況下關節不受控制，因此機器人將崩潰。 在上一階段添加關節時，我們以力<span>/</span>扭矩模式創建了關節，但其電動機或控制器已禁用（默認情況下）。 現在，我們可以根據需要調整關節。 在我們的案例中，我們希望為每個控制器都提供一個簡單的<span>PID</span>控制器。 在關節動態屬性中，單擊“啟用電機”並調整最大扭矩。 然後，單擊啟用控制環，然後選擇位置控制（<span>PID</span>）。 現在，我們再次運行仿真：機器人應保持其位置。 嘗試切換當前的物理引擎，以查看行為在所有受支持的物理引擎之間是否一致。 您可以通過相應的工具欄按鈕或在常規動力學屬性中執行此操作。</p>
<p> </p>
<p>在仿真過程中，我們現在通過“動態內容可視化和驗證”工具欄按鈕來驗證場景動態內容。 現在，將僅顯示物理引擎考慮的項目，並且該顯示使用顏色編碼。 始終執行此操作非常重要，尤其是在動態模型無法按預期運行時，為了快速調試模型，尤其如此。 同樣，在仿真過程中請始終查看場景層次：動態啟用的對象應在其名稱的右側顯示一個球形圖標。</p>
<p>*photo 04</p>
<p><img alt="" height="852" src="/images/photo 04.png" width="1009"/></p>
<p>Finally, we need to prepare the robot so that we can easily attach a gripper to it, or easily attach the robot to a mobile platform (for instance). Two dynamically enabled shapes can be rigidly attached to each other in two different ways:</p>
<p> </p>
<p>by grouping them: select the shapes, then [Menu bar --&gt; Edit --&gt; Grouping/Merging --&gt; Group selected shapes].</p>
<p>by attaching them via a force/torque sensor: a force torque sensor can also act as a rigid link between two separate dynamically enabled shapes.</p>
<p>In our case, only option 2 is of interest. We create a force/torque sensor with [Menu bar --&gt; Add --&gt; Force sensor], then move it to the tip of the robot, then attach it to object robot_link_dyn6. We change its size and visual appearance appropriately (a red force/torque sensor is often perceived as an optional attachment point, check the various robot models available). We also change its name to robot_attachment:</p>
<p> </p>
<p>最後，我們需要準備機器人，以便我們可以輕鬆地將抓取器連接到它，或輕鬆地將機器人連接到移動平台（例如）。 可以通過兩種不同的方式將兩個動態啟用的形狀嚴格地彼此附加：</p>
<p> </p>
<p>通過對它們進行分組：選擇形狀，然後選擇<span>[</span>菜單欄<span>-&gt;</span>編輯<span>-&gt;</span>分組<span>/</span>合併<span>-&gt;</span>對選定形狀進行分組<span>]</span>。</p>
<p>通過通過力<span>/</span>扭矩傳感器進行連接：力扭矩傳感器還可以充當兩個單獨的動態啟用形狀之間的剛性鏈接。</p>
<p>在我們的情況下，只有選項<span>2</span>是有意義的。 我們使用<span>[</span>菜單欄<span>-&gt;</span>添加<span>-&gt;</span>力傳感器<span>]</span>創建一個力<span>/</span>扭矩傳感器，然後將其移動到機器人的尖端，然後將其附加到對象<span>robot_link_dyn6</span>。 我們會適當地更改其尺寸和外觀（紅色力<span>/</span>扭矩傳感器通常被視為可選的連接點，請檢查可用的各種機器人型號）。 我們還將其名稱更改為<span>robot_attachment</span>：</p>
<p>*photo 05</p>
<p><img alt="" height="845" src="/images/photo 05.png" width="1003"/></p>
<p>Now we drag a gripper model into the scene, keep it selected, then control-click the attachment force sensor, then click the Assembling/disassembling toolbar button. The gripper goes into place:</p>
<p>現在，我們將抓手模型拖到場景中，使其保持選中狀態，然後按住<span>Control</span>鍵單擊並單擊附著力傳感器，然後單擊“裝配<span>/</span>拆卸”工具欄按鈕。 夾持器到位：</p>
<p>*photo 06</p>
<p><img alt="" height="532" src="/images/photo 06.png" width="695"/></p>
<p>The gripper knew how to attach itself because it was appropriately configured during its model definition. We now also need to properly configure the robot model, so that it will know how to attach itself to a mobile base for instance. We select the robot model, then click Assembling in the object common properties. Set an empty string for 'Parent' match values, then click Set matrix. This will memorize the current base object's local transformation matrix, and use it to position/orient itself relative to the mobile robot's attachment point. To verify that we did things right, we drag the model Models/robots/mobile/KUKA Omnirob.ttm into the scene. Then we select our robot model, then control-click one of the attachment points on the mobile platform, then click the Assembling/disassembling toolbar button. Our robot should correctly place itself on top of the mobile robot:</p>
<p> </p>
<p>抓具知道如何附加自身，因為它在模型定義期間進行了適當的配置。 現在，我們還需要正確配置機器人模型，以便它將知道如何將自己附加到移動基座上。 我們選擇機器人模型，然後在對象公共屬性中單擊“組裝”。 為“父項”匹配值設置一個空字符串，然後單擊“設置矩陣”。 這將記住當前基礎對象的局部轉換矩陣，並使用它相對於移動機器人的附著點定位<span>/</span>定向。 為了驗證我們做的正確，我們將模型<span>Models / robots / mobile / KUKA Omnirob.ttm</span>拖到場景中。 然後，我們選擇機器人模型，然後在移動平台上按住<span>Control</span>鍵並單擊其中一個附接點，然後單擊“組裝<span>/</span>拆卸”工具欄按鈕。 我們的機器人應該正確地將自己放置在移動機器人的頂部：</p>
<p>*photo 07</p>
<p><img alt="" height="659" src="/images/photo 07.png" width="419"/></p>
<p>Now we could add additional items to our robot, such as sensors for instance. At some point we might also want to attach embedded scripts to our model, in order to control its behaviour or configure it for various purposes. In that case, make sure to understand how object handles are accessed from embedded scripts. We can also control/access/interface our model from a plugin, from a remote API client, from a ROS node, from a BlueZero node, or from an add-on.</p>
<p> </p>
<p>Now we make sure we have reverted the changes done during robot and gripper attachment, we collapse the hierarchy tree of our robot model, select the base of our model, then save it with [Menu bar --&gt; File --&gt; Save model as...]. If we saved it in the model folder, then the model will be available in the model brower.</p>
<p><span> </span></p>
<p>現在，我們可以向機器人添加其他項目，例如傳感器。 在某些時候，我們可能還希望將嵌入式腳本附加到我們的模型中，以便控制其行為或出於各種目的對其進行配置。 在這種情況下，請確保了解如何從嵌入式腳本訪問對象句柄。 我們還可以通過插件，遠程<span>API</span>客戶端，<span>ROS</span>節點，<span>BlueZero</span>節點或附加組件來控制<span>/</span>訪問<span>/</span>接口模型。</p>
<p> </p>
<p>現在，確保已恢復在機械手和抓爪安裝過程中所做的更改，我們折疊了機械手模型的層次樹，選擇了模型的基礎，然後使用<span>[</span>菜單欄<span>-&gt;</span>文件<span>-&gt;</span>將模型另存為<span> ...]</span>。 如果我們將其保存在模型文件夾中，則模型將在模型瀏覽器中可用。</p>
<h1>About</h1>
<p>此內容管理系統以 <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 作為 submodule 運作, 可以選定對應的版本運作, cmsimde 可以持續改版, 不會影響之前設為 submodule, 使用舊版 cmsimde 模組的內容管理相關運作.</p>
<h4>利用 cmsimde 建立靜態網誌方法:</h4>
<p>1. 在 github 建立倉儲, git clone 到近端</p>
<p>2. 參考 <a href="https://github.com/mdecourse/newcms">https://github.com/mdecourse/newcms</a>, 加入除了 cmsimde 目錄外的所有內容</p>
<p>以 git submodule add <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> cmsimde</p>
<p>建立 cmsimde 目錄, 並從 github 取下子模組內容.</p>
<p>3.在近端維護時, 更換目錄到倉儲中的 cmsimde, 以 python wsgi.py 啟動近端網際伺服器.</p>
<p>動態內容編輯完成後, 以 generate_pages 轉為靜態內容, 以 git add commit 及 push 將內容推到遠端.</p>
<p>4. 之後若要以 git clone 取下包含 submodule 的所有內容, 執行:</p>
<p>git clone --recurse-submodules <a href="https://github.com/mdecourse/newcms.git">https://github.com/mdecourse/newcms.git</a></p>
<h1>Develop</h1>
<p><a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 的開發, 可以在一個目錄中放入 cmsimde, 然後將 up_dir 中的內容放到與 cmsimde 目錄同位階的地方, 使用 command 進入 cmsimde 目錄, 執行 python wsgi.py, 就可以啟動, 以瀏覽器 https://localhost:9443 就可以連接, 以 admin 作為管理者密碼, 就可以登入維護內容.</p>
<p>cmsimde 的開發採用 Leo Editor, 開啟 cmsimde 目錄中的 cmsimde.leo 就可以進行程式修改, 結束後, 若要保留網際內容, 只要將 cmsimde 外部的內容倒回 up_dir 目錄中即可後續對 cmsimde 遠端倉儲進行改版.</p>
<p>init.py 位於  up_dir 目錄, 可以設定 site_title 與 uwsgi 等變數.</p>